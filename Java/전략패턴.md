# Strategy Pattern

자주 변경되는 부분을 추상 클래스 혹은 인터페이스로 분리하고, 변경되는 부분에 대한 구현 객체를 만들어 사용하는 측에서 어떤 객체 타입을 호출한지 모르는 상태에서 프로그램이 동작하는 방식?

달라지는 부분을 찾아서 나머지 코드에 영향을 주지 않도록 "캡슐화" 하는 패턴

## 왜 사용할까?
1. 상속을 통해 프로그램을 확장할 경우 서브클래스에 적합하지 않은 행동들이 전부 추가된다.
2. 서브 클래스에서 해당 메소드를 오버라이드하여 기능을 변경하는 방식은 적합하지 않다.
3. 서브 클래스에서 인터페이스를 구현하는 방법이 좋아보이지만, 인터페이스는 구현된 코드가 전혀 들어가지 않기 때문에(default 메소드 제외)
코드 재사용을 할 수 없다는 문제가 존재한다. 즉, 한 행동을 바꿀 때마다 그 행동이 정의되어 있는 서브 클래스를 전부 다 찾아서 코드를 일일이 고쳐야 한다. 이 과정에서 추가적인 버그를 만날 가능성이 존재한다.

이런 상황에선 어울리는 디자인 원칙이 있다.
```바로 애플리케이션에서 달라지는 부분을 찾아 내고, 달라지지 않은 부분으로부터 분리시킨다.```
즉, 코드에 새로운 요구사항이 있을 때마다 바뀌는 부분이 있다면, 그 행동을 바뀌지 않는 다른 부분으로부터 골라내서 분리해야 한다는 것이다.


## 언제 사용할까?
바뀌는 부분과 그렇지 않은 부분을 분리하기 구현을 하다보면 잘 작동되는 부분과 자주 변경되는 부분을 찾을 수 있다.
이 달라지는 부분을 별도의 집합으로 구분해서 사용하고 적용시킨다면 우리는 전략패턴에 대한 내용을 거의 이해할 수 있다.

전략 패턴의 주요 포인트는 유연성이다. 자주 변경되는 부분은 그 만큼 유연해야한다.
즉, 하나의 구현체의 의존하지 않도록 분리해야한다는 것이다.

## 변화하는 부분을 뽑아내자
책에 나와 있는 예제코드로 설명하겠다. 
지금까지 살펴본 바로는, fly()와 quack() 문제를 제외하면 Duck 클래스는 정상적으로 동작하고 있으며, 나머지 부분은 자주 달라지거나 바뀌지 않는다.

그렇기 때문에 여기서 변화하는 부분과 그대로 있는 부분을 추출할 수 있다.
변화하는 부분 : fly, quack
변화하지 않는 부분 : fly, quack 행동을 제외한 나머지 Duck 클래스

변화하는 부분을 별도의 집합으로 만들어보면 하나는 나는 것과 관련된 집합이고 다른 하나는 꽥꽥거리는 것과 관련된 집합이다.
각 집합에는 각각의 행동을 구현한 것을 전부 집어넣는다.
꽥꽥거리는 집합안에 삑삑거리는 것을 구현하는 클래스를 만들고, 아무 소리도 내지 않는 것을 구현하는 클래스를 넣고, 박박우는 소리를 내는 것을 구현하는 클래스를 만드는 것이다. 말 그대로 꽥꽥거리는 것과 연관된 부분들은 다 때려박는다는 이야기이다.

꽥꽥(행동) 집합 - 삑빅(구현), 아무것도 업음(구현), 삐이익(구현), 삐비비삑(구현)
나는(행동) 집합 - 로켓날기(구현), 날개날기(구현), 풍선날기(구현), 바람에날기(구현)

## 행동을 구현하는 클래스는 어떻게 디자인해야할까?
먼저 최대한 유연하게 만드는 것이 좋다. 애초에 이런 디자인 패턴을 고려하게 된 이유는 결국 오리의 행동과 관련된 유연성 때문이다.
그리고 Duck 인스턴스에 행동을 할당할 수 있게 만들어야한다.

예를 들어 MallardDuck 인스턴스를 새로 생성할 때, 생성자로 꽥꽥 행동과 나는 행동을 초기화하는 방법이 좋은 방법일 것이다.
그리고 프로그램 실행중에도 동적으로 오리의 행동을 변경할 수 있다면 유연성은 더욱 증가하게 될 것이다.

## 구현이 아닌 인터페이스에 맞춰서 프로그래밍한다.
각 행동은 인터페이스로 표현하고 행동을 구현할 때 이런 인터페이스를 구현하도록 만든다.

즉, 나는 행동과 꽥꽥거리는 행동은 더이상 Duck 클래스에서 구현하는 것이 아닌 행동(behavior)만을 목적으로 하는 클래스를 만드는 것이다.
이제부터 행동(behavior) 인터페이스는 Duck 클래스가 아닌, 행동 클래스에서 구현한다.

이 ```방법은 행동을 Duck 클래스에서 구체적으로 구현하거나 서브 클래스 자체에서 별도로 구현하는 방법하고는 전혀 상반된 방법```이다.
전에 사용하던 방식은 항상 특정 구현에 의존해야했다. (특정 구현에 의존하는 로직을 다시 보여준다.)

## 행동을 만들 때, 왜 인터페이스를 써야할까? 추상 클래스도 똑같은 일을 할 수 있다.
여기서 핵심은 실제 실행시 쓰이는 객체가 코드에 의해서 고정되지 않도록 어떤 상위 형식에 맞춰서 프로그래밍함으로써 다형성을 활용하라는 뜻이다.
변수를 선언할 때는 보통 추상 클래스나 인터페이스 같은 상위 형식으로 선언해야 한다. 객체를 변수에 대입할 때 상위 형식을 구체적으로 구현항 형식이라면
어떤 객체든 집어넣을 수 있기 때문이다. 그렇게 하면 변수를 선언하는 클래스에서 실제 객체의 형식은 몰라도 되기 때문이다.

그렇다면 인터페이스를 주로 사용하는 이유는 뭘까?
가장 큰 차이점은 다중 상속의 여부이다. 나는 행동에 대해서 인터페이스와 추상 클래스 2가지 방식으로 구현했다고 가정해보자
만약 여기서 나는 행동과 관련된 행동들이 몇가지 추가되었다고 가정해보면 인터페이스는 행동들에 대해서 다중으로 상속받을 수 있다.
하지만 추상 클래스는 나는 행동 추상 클래스를 상속받아서 추가적인 행동들에 대한 추상 클래스를 또 만들어줘야 한다. 기능이 많으면 많아질수록 추상 클래스의 개수는 점차적으로 증가하게 되는 문제점이 발생하게 된다.